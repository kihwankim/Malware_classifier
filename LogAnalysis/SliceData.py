import csv
from datetime import datetime, date
import ReadLog


def slice_time_and_record(slice_time, list):  # 시간 단위로 나눠서 표로 저장함
    """
    :param slice_time: microsec 로 자르고 싶은 시간
    :param list: process monitor 에서 수집한 log data 를 가지고있는 list
    :return:
    """
    # 1 : index of file name
    # 3 : index of reg func name

    dict_of_sets = __get_regfunc_and_file_name(list, index_of_func=3, index_of_filename=1)
    set_of_regfunc = dict_of_sets['func_name']
    set_of_filename = dict_of_sets['file_name']

    file_obj_controller = {}  # 모든 reg func에 대한 file 객체 생성
    writer_controller = {}  # writer 객체를 담는 dict

    for reg_func_name in set_of_regfunc:
        try:
            csv_file = open(reg_func_name + '.csv', 'w', newline='')
            file_obj_controller[reg_func_name] = csv_file
            data_writer = csv.DictWriter(csv_file,
                                         fieldnames=set_of_filename)  # file name을 col로 두고 row를 time slice 로 한다
            data_writer.writeheader()  # header 입력
            writer_controller[reg_func_name] = data_writer
        except:
            print("error")

    # 출력문 모든 자료형들의 출력문
    dict_of_all_data = __classify_each_func_and_filename(list, set_of_regfunc, set_of_filename)

    # 결과 데이터
    dict_result_of_all = {}

    for key, value in dict_of_all_data.items():
        print("reg func name", key)
        max_row_number = 0
        for inner_key in value:
            print("mal file name :", inner_key)
            print("length :", len(value[inner_key]))
            print(value[inner_key])
            number_of_slice_row = __cal_length_of_csv_col(slice_time, value[inner_key][0][0],
                                                          value[inner_key][len(value[inner_key]) - 1][0])
            if int(number_of_slice_row) > max_row_number:
                if number_of_slice_row % 1 > 0:
                    int_number_of_slice_row = int(number_of_slice_row) + 1
                else:
                    int_number_of_slice_row = int(number_of_slice_row)
                max_row_number = int_number_of_slice_row

        list_of_calculated_data = [{} for _ in range(max_row_number)]  # result

        for inner_key in value:
            last_time = value[inner_key][0][0]
            index_of_row = 0
            for index_of_list_for_cal in range(len(value[inner_key])):
                term_of_time_data = __date_to_microseconds(
                    __cal_time(last_time, value[inner_key][index_of_list_for_cal][0]))
                if index_of_list_for_cal == 0:
                    list_of_calculated_data[index_of_row][inner_key] = 1
                elif term_of_time_data <= slice_time:
                    try:
                        list_of_calculated_data[index_of_row][inner_key] += 1
                    except Exception:
                        list_of_calculated_data[index_of_row][inner_key] = 1
                else:
                    index_of_row = index_of_row + int(term_of_time_data / 100)
                    list_of_calculated_data[index_of_row][inner_key] = 1
                    last_time = value[inner_key][index_of_list_for_cal][0]

        dict_result_of_all[key] = list_of_calculated_data

        # 출력결과 확인

        sum = 0
        for dict_data in list_of_calculated_data:
            for key, value in dict_data.items():
                sum += value
        print(sum)

        # 결과 확인

    # insert all
    __record_each_data_in_list(dict_result_of_all, writer_controller)

    __close_file_controller(file_obj_controller)  # 모든 객체 소멸


def __record_each_data_in_list(dict_list, writer_controller):
    """
    해당 time 만큼 나눠서 저장
    :param slice_time : 짜르고자 하는 단위
    :param dict_list : 모든 data
     record all the data in each files
    """
    for key_of_regfunc_name, value_of_regfunc_log in dict_list.items():
        for log_data in value_of_regfunc_log:
            writer_controller[key_of_regfunc_name].writerow(log_data)



def __classify_each_func_and_filename(list_all, set_of_regfunc, set_of_filename):
    """
    :param list_all: 모든 로그 정보가 들어가 있는 list
    :param set_of_regfunc: regname set
    :param set_of_filename: filename set
    :return: dict - key : reg func name, value : dict - key : mal file name, value : log list
    """
    result_of_reg_function_classified = __classify_about_function(list_all, set_of_regfunc)
    result_of_reg_func_mal = {}
    for now_func_name in result_of_reg_function_classified:  # now_func_name : regfunc name
        result_of_reg_func_mal[now_func_name] = __classify_about_file_name(
            result_of_reg_function_classified[now_func_name], set_of_filename)

    return result_of_reg_func_mal


def __classify_about_function(list_all, set_of_regname):  # 함수에 대해서 분류
    """
    :param list_all: 모든 로그정보가 담겨져 있는 변수
    :param set_of_regname: 레지스트리 함수 이름이 담겨져 있는 set
    :return: key : 레지스트리 함수 이름, value : 함수 실행한 모든 로그들 list
    """
    dict_of_each_func = {}
    for regfunc_name in set_of_regname:
        dict_of_each_func[regfunc_name] = ReadLog.pull_out_from_list(3, regfunc_name, list_all)

    return dict_of_each_func


def __classify_about_file_name(each_list_about_reg_func_name, set_of_filename):
    """
    :param each_list_about_reg_func_name: 로그 정보를 담고있는 list
    :param set_of_filename: file 이름이 담겨져 있는 set
    :return: key : filename, value : 해당 로그 list
    """
    dict_of_each_file_name = {}
    for filename in set_of_filename:
        dict_of_each_file_name[filename] = ReadLog.pull_out_from_list(1, filename, each_list_about_reg_func_name)

    return dict_of_each_file_name


def __get_regfunc_and_file_name(data_list, index_of_func, index_of_filename):
    """
    :param data_list: list of data
    :param index_of_func: index of reg function
    :param index_of_filename: index of file name
    :return: dict of set
    """
    set_of_filename = set()
    set_of_regfunc = set()
    for each_list_data in data_list:
        set_of_filename.add(each_list_data[index_of_filename])
        set_of_regfunc.add(each_list_data[index_of_func])

    return {'file_name': set_of_filename, 'func_name': set_of_regfunc}


def __cal_length_of_csv_col(slice_time, start_time, last_time):  # 해당 얼마만큼 row 를 가질지 에 대한 것
    return __date_to_microseconds(__cal_time(start_time, last_time)) / slice_time


def __close_file_controller(dict_of_files):
    for dict_data in dict_of_files:
        dict_of_files[dict_data].close()


def __cal_time(first_time, second_time):
    """
    :param first_time: time obj of start time
    :param second_time: time obj of end time
    :return: datetime type of obj of subtract of them
    """

    datetime_a = datetime.combine(date.today(), first_time)
    datetime_b = datetime.combine(date.today(), second_time)
    # Get the difference between datetimes (as timedelta)

    date_time_difference = datetime_b - datetime_a
    # Divide difference in seconds by number of seconds in hour (3600)

    return date_time_difference


def __date_to_microseconds(date):  # microsecond 로 변환해 준다
    """
    :param date: datetime deltime obj
    :return: double type microseconds
    """
    millis = date.days * 24 * 60 * 60 * 1000
    millis += date.seconds * 1000
    millis += date.microseconds / 1000
    return millis
